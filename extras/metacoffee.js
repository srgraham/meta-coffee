// Generated by uRequire v0.6.10 - template: 'combined' 
// Combined template optimized with RequireJS/r.js v2.1.4 & almond.
(function (global, window){
  
var __isAMD = !!(typeof define === 'function' && define.amd),
    __isNode = (typeof exports === 'object'),
    __isWeb = !__isNode;

  var __nodeRequire = (__isNode ? require :
      function(dep){
        throw new Error("uRequire detected missing dependency: '" + dep + "' - in a non-nodejs runtime. All it's binding variables were 'undefined'.")
      });
var bundleFactory = function(BSCoffeeScriptCompiler, js_beautify) {
/**
 * almond 0.2.7 Copyright (c) 2011-2012, The Dojo Foundation All Rights Reserved.
 * Available via the MIT or new BSD license.
 * see: http://github.com/jrburke/almond for details
 */
//Going sloppy to avoid 'use strict' string cost, but strict practices should
//be followed.
/*jslint sloppy: true */
/*global setTimeout: false */

var requirejs, require, define;
(function (undef) {
    var main, req, makeMap, handlers,
        defined = {},
        waiting = {},
        config = {},
        defining = {},
        hasOwn = Object.prototype.hasOwnProperty,
        aps = [].slice;

    function hasProp(obj, prop) {
        return hasOwn.call(obj, prop);
    }

    /**
     * Given a relative module name, like ./something, normalize it to
     * a real name that can be mapped to a path.
     * @param {String} name the relative name
     * @param {String} baseName a real name that the name arg is relative
     * to.
     * @returns {String} normalized name
     */
    function normalize(name, baseName) {
        var nameParts, nameSegment, mapValue, foundMap,
            foundI, foundStarMap, starI, i, j, part,
            baseParts = baseName && baseName.split("/"),
            map = config.map,
            starMap = (map && map['*']) || {};

        //Adjust any relative paths.
        if (name && name.charAt(0) === ".") {
            //If have a base name, try to normalize against it,
            //otherwise, assume it is a top-level require that will
            //be relative to baseUrl in the end.
            if (baseName) {
                //Convert baseName to array, and lop off the last part,
                //so that . matches that "directory" and not name of the baseName's
                //module. For instance, baseName of "one/two/three", maps to
                //"one/two/three.js", but we want the directory, "one/two" for
                //this normalization.
                baseParts = baseParts.slice(0, baseParts.length - 1);

                name = baseParts.concat(name.split("/"));

                //start trimDots
                for (i = 0; i < name.length; i += 1) {
                    part = name[i];
                    if (part === ".") {
                        name.splice(i, 1);
                        i -= 1;
                    } else if (part === "..") {
                        if (i === 1 && (name[2] === '..' || name[0] === '..')) {
                            //End of the line. Keep at least one non-dot
                            //path segment at the front so it can be mapped
                            //correctly to disk. Otherwise, there is likely
                            //no path mapping for a path starting with '..'.
                            //This can still fail, but catches the most reasonable
                            //uses of ..
                            break;
                        } else if (i > 0) {
                            name.splice(i - 1, 2);
                            i -= 2;
                        }
                    }
                }
                //end trimDots

                name = name.join("/");
            } else if (name.indexOf('./') === 0) {
                // No baseName, so this is ID is resolved relative
                // to baseUrl, pull off the leading dot.
                name = name.substring(2);
            }
        }

        //Apply map config if available.
        if ((baseParts || starMap) && map) {
            nameParts = name.split('/');

            for (i = nameParts.length; i > 0; i -= 1) {
                nameSegment = nameParts.slice(0, i).join("/");

                if (baseParts) {
                    //Find the longest baseName segment match in the config.
                    //So, do joins on the biggest to smallest lengths of baseParts.
                    for (j = baseParts.length; j > 0; j -= 1) {
                        mapValue = map[baseParts.slice(0, j).join('/')];

                        //baseName segment has  config, find if it has one for
                        //this name.
                        if (mapValue) {
                            mapValue = mapValue[nameSegment];
                            if (mapValue) {
                                //Match, update name to the new value.
                                foundMap = mapValue;
                                foundI = i;
                                break;
                            }
                        }
                    }
                }

                if (foundMap) {
                    break;
                }

                //Check for a star map match, but just hold on to it,
                //if there is a shorter segment match later in a matching
                //config, then favor over this star map.
                if (!foundStarMap && starMap && starMap[nameSegment]) {
                    foundStarMap = starMap[nameSegment];
                    starI = i;
                }
            }

            if (!foundMap && foundStarMap) {
                foundMap = foundStarMap;
                foundI = starI;
            }

            if (foundMap) {
                nameParts.splice(0, foundI, foundMap);
                name = nameParts.join('/');
            }
        }

        return name;
    }

    function makeRequire(relName, forceSync) {
        return function () {
            //A version of a require function that passes a moduleName
            //value for items that may need to
            //look up paths relative to the moduleName
            return req.apply(undef, aps.call(arguments, 0).concat([relName, forceSync]));
        };
    }

    function makeNormalize(relName) {
        return function (name) {
            return normalize(name, relName);
        };
    }

    function makeLoad(depName) {
        return function (value) {
            defined[depName] = value;
        };
    }

    function callDep(name) {
        if (hasProp(waiting, name)) {
            var args = waiting[name];
            delete waiting[name];
            defining[name] = true;
            main.apply(undef, args);
        }

        if (!hasProp(defined, name) && !hasProp(defining, name)) {
            throw new Error('No ' + name);
        }
        return defined[name];
    }

    //Turns a plugin!resource to [plugin, resource]
    //with the plugin being undefined if the name
    //did not have a plugin prefix.
    function splitPrefix(name) {
        var prefix,
            index = name ? name.indexOf('!') : -1;
        if (index > -1) {
            prefix = name.substring(0, index);
            name = name.substring(index + 1, name.length);
        }
        return [prefix, name];
    }

    /**
     * Makes a name map, normalizing the name, and using a plugin
     * for normalization if necessary. Grabs a ref to plugin
     * too, as an optimization.
     */
    makeMap = function (name, relName) {
        var plugin,
            parts = splitPrefix(name),
            prefix = parts[0];

        name = parts[1];

        if (prefix) {
            prefix = normalize(prefix, relName);
            plugin = callDep(prefix);
        }

        //Normalize according
        if (prefix) {
            if (plugin && plugin.normalize) {
                name = plugin.normalize(name, makeNormalize(relName));
            } else {
                name = normalize(name, relName);
            }
        } else {
            name = normalize(name, relName);
            parts = splitPrefix(name);
            prefix = parts[0];
            name = parts[1];
            if (prefix) {
                plugin = callDep(prefix);
            }
        }

        //Using ridiculous property names for space reasons
        return {
            f: prefix ? prefix + '!' + name : name, //fullName
            n: name,
            pr: prefix,
            p: plugin
        };
    };

    function makeConfig(name) {
        return function () {
            return (config && config.config && config.config[name]) || {};
        };
    }

    handlers = {
        require: function (name) {
            return makeRequire(name);
        },
        exports: function (name) {
            var e = defined[name];
            if (typeof e !== 'undefined') {
                return e;
            } else {
                return (defined[name] = {});
            }
        },
        module: function (name) {
            return {
                id: name,
                uri: '',
                exports: defined[name],
                config: makeConfig(name)
            };
        }
    };

    main = function (name, deps, callback, relName) {
        var cjsModule, depName, ret, map, i,
            args = [],
            callbackType = typeof callback,
            usingExports;

        //Use name if no relName
        relName = relName || name;

        //Call the callback to define the module, if necessary.
        if (callbackType === 'undefined' || callbackType === 'function') {
            //Pull out the defined dependencies and pass the ordered
            //values to the callback.
            //Default to [require, exports, module] if no deps
            deps = !deps.length && callback.length ? ['require', 'exports', 'module'] : deps;
            for (i = 0; i < deps.length; i += 1) {
                map = makeMap(deps[i], relName);
                depName = map.f;

                //Fast path CommonJS standard dependencies.
                if (depName === "require") {
                    args[i] = handlers.require(name);
                } else if (depName === "exports") {
                    //CommonJS module spec 1.1
                    args[i] = handlers.exports(name);
                    usingExports = true;
                } else if (depName === "module") {
                    //CommonJS module spec 1.1
                    cjsModule = args[i] = handlers.module(name);
                } else if (hasProp(defined, depName) ||
                           hasProp(waiting, depName) ||
                           hasProp(defining, depName)) {
                    args[i] = callDep(depName);
                } else if (map.p) {
                    map.p.load(map.n, makeRequire(relName, true), makeLoad(depName), {});
                    args[i] = defined[depName];
                } else {
                    throw new Error(name + ' missing ' + depName);
                }
            }

            ret = callback ? callback.apply(defined[name], args) : undefined;

            if (name) {
                //If setting exports via "module" is in play,
                //favor that over return value and exports. After that,
                //favor a non-undefined return value over exports use.
                if (cjsModule && cjsModule.exports !== undef &&
                        cjsModule.exports !== defined[name]) {
                    defined[name] = cjsModule.exports;
                } else if (ret !== undef || !usingExports) {
                    //Use the return value from the function.
                    defined[name] = ret;
                }
            }
        } else if (name) {
            //May just be an object definition for the module. Only
            //worry about defining if have a module name.
            defined[name] = callback;
        }
    };

    requirejs = require = req = function (deps, callback, relName, forceSync, alt) {
        if (typeof deps === "string") {
            if (handlers[deps]) {
                //callback in this case is really relName
                return handlers[deps](callback);
            }
            //Just return the module wanted. In this scenario, the
            //deps arg is the module name, and second arg (if passed)
            //is just the relName.
            //Normalize module name, if it contains . or ..
            return callDep(makeMap(deps, callback).f);
        } else if (!deps.splice) {
            //deps is a config object, not an array.
            config = deps;
            if (callback.splice) {
                //callback is an array, which means it is a dependency list.
                //Adjust args if there are dependencies
                deps = callback;
                callback = relName;
                relName = null;
            } else {
                deps = undef;
            }
        }

        //Support require(['a'])
        callback = callback || function () {};

        //If relName is a function, it is an errback handler,
        //so remove it.
        if (typeof relName === 'function') {
            relName = forceSync;
            forceSync = alt;
        }

        //Simulate async callback;
        if (forceSync) {
            main(undef, deps, callback, relName);
        } else {
            //Using a non-zero value because of concern for what old browsers
            //do, and latest browsers "upgrade" to 4 if lower value is used:
            //http://www.whatwg.org/specs/web-apps/current-work/multipage/timers.html#dom-windowtimers-settimeout:
            //If want a value immediately, use require('id') instead -- something
            //that works in almond on the global level, but not guaranteed and
            //unlikely to work in other AMD implementations.
            setTimeout(function () {
                main(undef, deps, callback, relName);
            }, 4);
        }

        return req;
    };

    /**
     * Just drops the config on the floor, but returns req in case
     * the config return value is used.
     */
    req.config = function (cfg) {
        config = cfg;
        if (config.deps) {
            req(config.deps, config.callback);
        }
        return req;
    };

    /**
     * Expose module registry for debugging and tooling
     */
    requirejs._defined = defined;

    define = function (name, deps, callback) {

        //This module may not have dependencies
        if (!deps.splice) {
            //deps is not an array, so probably means
            //an object literal or factory function for
            //the value. Adjust args.
            callback = deps;
            deps = [];
        }

        if (!hasProp(defined, name) && !hasProp(waiting, name)) {
            waiting[name] = [name, deps, callback];
        }
    };

    define.amd = {
        jQuery: true
    };
}());

define("almond", function(){});

define('path',[],function () {
  if (__isNode) {
  return __nodeRequire('path');
} else {
  throw new Error("uRequire: trying to access unbound / excluded 'node-only' dependency 'path') on browser");
}
});
define('fs',[],function () {
  if (__isNode) {
  return __nodeRequire('fs');
} else {
  throw new Error("uRequire: trying to access unbound / excluded 'node-only' dependency 'fs') on browser");
}
});
define('ometa-base',['require','exports','module'],function (require, exports, module) {
  

var ListOMInputStream, OMInputStream, OMInputStreamEnd, OMeta, getTag, isImmutable, isSequenceable, makeOMInputStreamProxy, objectThatDelegatesTo, stringDigitValue, __hasProp = {}.hasOwnProperty, __extends = function (child, parent) {
    for (var key in parent) {
      if (__hasProp.call(parent, key))
        child[key] = parent[key];
    }
    function ctor() {
      this.constructor = child;
    }
    ctor.prototype = parent.prototype;
    child.prototype = new ctor();
    child.__super__ = parent.prototype;
    return child;
  }, __slice = [].slice;
isImmutable = function (x) {
  return x === null || x === void 0 || typeof x === "boolean" || typeof x === "number" || typeof x === "string";
};
stringDigitValue = function (string) {
  return string.charCodeAt(0) - "0".charCodeAt(0);
};
isSequenceable = function (x) {
  return typeof x === "string" || x.constructor === Array;
};
getTag = function () {
  var numIdx;
  numIdx = 0;
  return function (x) {
    if (x == null) {
      x;
    }
    switch (typeof x) {
    case "boolean":
      if (x === true) {
        return "Btrue";
      } else {
        return "Bfalse";
      }
      break;
    case "string":
      return "S" + x;
    case "number":
      return "N" + x;
    default:
      if (x.hasOwnProperty("_id_")) {
        return x._id_;
      } else {
        return x._id_ = "R" + numIdx++;
      }
    }
  };
}();
OMInputStream = function () {
  function OMInputStream(hd, tl) {
    this.hd = hd;
    this.tl = tl;
    this.memo = {};
    this.lst = tl.lst;
    this.idx = tl.idx;
  }
  OMInputStream.prototype.head = function () {
    return this.hd;
  };
  OMInputStream.prototype.tail = function () {
    return this.tl;
  };
  OMInputStream.prototype.type = function () {
    return this.lst.constructor;
  };
  OMInputStream.prototype.upTo = function (that) {
    var curr, r;
    r = [];
    curr = this;
    while (curr !== that) {
      r.push(curr.head());
      curr = curr.tail();
    }
    if (this.type() === String) {
      return r.join("");
    } else {
      return r;
    }
  };
  return OMInputStream;
}();
OMInputStreamEnd = function (_super) {
  __extends(OMInputStreamEnd, _super);
  function OMInputStreamEnd(lst, idx) {
    this.lst = lst;
    this.idx = idx;
    this.memo = {};
  }
  OMInputStreamEnd.prototype.head = function () {
    throw OMeta.prototype.fail;
  };
  OMInputStreamEnd.prototype.tail = function () {
    throw OMeta.prototype.fail;
  };
  return OMInputStreamEnd;
}(OMInputStream);
ListOMInputStream = function (_super) {
  var makeStreamFrom;
  __extends(ListOMInputStream, _super);
  function ListOMInputStream(lst, idx) {
    this.lst = lst;
    this.idx = idx;
    this.memo = {};
    this.hd = lst[idx];
  }
  ListOMInputStream.prototype.head = function () {
    return this.hd;
  };
  ListOMInputStream.prototype.tail = function () {
    return this.tl || (this.tl = makeStreamFrom(this.lst, this.idx + 1));
  };
  makeStreamFrom = function (lst, idx) {
    var kind;
    kind = idx < lst.length ? ListOMInputStream : OMInputStreamEnd;
    return new kind(lst, idx);
  };
  ListOMInputStream.toStream = function (iterable) {
    return makeStreamFrom(iterable, 0);
  };
  return ListOMInputStream;
}(OMInputStream);
objectThatDelegatesTo = function (x, props) {
  var f, key, r, val;
  f = function () {
  };
  f.prototype = x;
  r = new f();
  for (key in props) {
    if (!__hasProp.call(props, key))
      continue;
    val = props[key];
    r[key] = val;
  }
  return r;
};
makeOMInputStreamProxy = function (target) {
  return objectThatDelegatesTo(target, {
    memo: {},
    target: target,
    tl: void 0,
    tail: function () {
      return this.tl || (this.tl = makeOMInputStreamProxy(target.tail()));
    }
  });
};
module.exports = OMeta = function () {
  OMeta.prototype.fail = {
    toString: function () {
      return "match failed";
    }
  };
  function OMeta(input) {
    this.input = input;
    this.initialize();
  }
  OMeta.prototype._apply = function (rule) {
    var ans, failer, memo, memoRec, origInput, sentinel;
    memo = this.input.memo;
    memoRec = memo[rule];
    if (memoRec === void 0) {
      origInput = this.input;
      if (this[rule] == null) {
        throw "tried to apply undefined rule \"" + rule + "\"";
      }
      memo[rule] = false;
      memoRec = {
        ans: this[rule].call(this),
        nextInput: this.input
      };
      failer = memo[rule];
      memo[rule] = memoRec;
      if (failer === true) {
        sentinel = this.input;
        while (true) {
          try {
            this.input = origInput;
            ans = this[rule].call(this);
            if (this.input === sentinel) {
              throw this.fail;
            }
            memoRec.ans = ans;
            memoRec.nextInput = this.input;
          } catch (f) {
            if (f !== this.fail) {
              throw f;
            }
            break;
          }
        }
      }
    } else if (typeof memoRec === "boolean") {
      memo[rule] = true;
      throw this.fail;
    }
    this.input = memoRec.nextInput;
    return memoRec.ans;
  };
  OMeta.prototype._applyWithArgs = function () {
    var args, idx, rule, ruleFn, ruleFnArity, _i, _ref;
    rule = arguments[0], args = 2 <= arguments.length ? __slice.call(arguments, 1) : [];
    ruleFn = this[rule];
    if (ruleFn == null) {
      throw "tried to apply undefined rule \"" + rule + "\"";
    }
    ruleFnArity = ruleFn.length;
    for (idx = _i = _ref = args.length - 1; _i >= ruleFnArity; idx = _i += -1) {
      this._prependInput(args[idx]);
    }
    if (ruleFnArity === 0) {
      return ruleFn.call(this);
    } else {
      return ruleFn.apply(this, args.slice(0, +ruleFnArity + 1 || 9000000000));
    }
  };
  OMeta._superApplyWithArgs = function () {
    var args, idx, recv, rule, ruleFn, ruleFnArity, _i, _ref;
    recv = arguments[0], rule = arguments[1], args = 3 <= arguments.length ? __slice.call(arguments, 2) : [];
    ruleFn = this.prototype[rule];
    if (ruleFn == null) {
      throw "tried to apply undefined super rule \"" + rule + "\"";
    }
    ruleFnArity = ruleFn.length;
    for (idx = _i = _ref = args.length - 1; _i > ruleFnArity; idx = _i += -1) {
      recv._prependInput(args[idx]);
    }
    if (ruleFnArity === 0) {
      return ruleFn.call(recv);
    } else {
      return ruleFn.apply(recv, args.slice(0, +(ruleFnArity + 1) + 1 || 9000000000));
    }
  };
  OMeta.prototype._prependInput = function (v) {
    return this.input = new OMInputStream(v, this.input);
  };
  OMeta.prototype.memoizeParameterizedRules = function () {
    this._prependInput = function (v) {
      var newInput;
      newInput = null;
      if (isImmutable(v)) {
        newInput = this.input[getTag(v)];
        if (!newInput) {
          newInput = new OMInputStream(v, this.input);
          this.input[getTag(v)] = newInput;
        }
      } else {
        newInput = new OMInputStream(v, this.input);
      }
      return this.input = newInput;
    };
    return this._applyWithArgs = function (rule) {
      var idx, ruleFn, ruleFnArity, _i, _ref;
      ruleFn = this[rule];
      ruleFnArity = ruleFn.length;
      for (idx = _i = _ref = args.length - 1; _i >= ruleFnArity; idx = _i += -1) {
        this._prependInput(arguments[idx]);
      }
      if (ruleFnArity === 0) {
        return this._apply(rule);
      } else {
        return this[rule].apply(this, arguments.slice(0, +ruleFnArity + 1 || 9000000000));
      }
    };
  };
  OMeta.prototype._pred = function (b) {
    if (b) {
      return true;
    }
    throw this.fail;
  };
  OMeta.prototype._not = function (x) {
    var origInput;
    origInput = this.input;
    try {
      x.call(this);
    } catch (f) {
      if (f !== this.fail) {
        throw f;
      }
      this.input = origInput;
      return true;
    }
    throw this.fail;
  };
  OMeta.prototype._lookahead = function (x) {
    var origInput, r;
    origInput = this.input;
    r = x.call(this);
    this.input = origInput;
    return r;
  };
  OMeta.prototype._or = function () {
    var arg, origInput, _i, _len;
    origInput = this.input;
    for (_i = 0, _len = arguments.length; _i < _len; _i++) {
      arg = arguments[_i];
      try {
        this.input = origInput;
        return arg.call(this);
      } catch (f) {
        if (f !== this.fail) {
          throw f;
        }
      }
    }
    throw this.fail;
  };
  OMeta.prototype._xor = function (ruleName) {
    var ans, idx, newInput, origInput;
    origInput = this.input;
    idx = 1;
    newInput = ans = null;
    while (idx < arguments.length) {
      try {
        this.input = origInput;
        ans = arguments[idx].call(this);
        if (newInput) {
          throw "more than one choice matched by \"exclusive-OR\" in " + ruleName;
        }
        newInput = this.input;
      } catch (f) {
        if (f !== this.fail) {
          throw f;
        }
      }
      idx++;
    }
    if (newInput) {
      this.input = newInput;
      return ans;
    } else {
      throw this.fail;
    }
  };
  OMeta.prototype.disableXORs = function () {
    return this._xor = this._or;
  };
  OMeta.prototype._opt = function (x) {
    var ans, origInput;
    origInput = this.input;
    ans = void 0;
    try {
      ans = x.call(this);
    } catch (f) {
      if (f !== this.fail) {
        throw f;
      }
      this.input = origInput;
    }
    return ans;
  };
  OMeta.prototype._many = function (x) {
    var ans, origInput;
    ans = arguments[1] !== void 0 ? [arguments[1]] : [];
    while (true) {
      origInput = this.input;
      try {
        ans.push(x.call(this));
      } catch (f) {
        if (f !== this.fail) {
          console.log("many error");
          console.log(f);
          throw f;
        }
        this.input = origInput;
        break;
      }
    }
    return ans;
  };
  OMeta.prototype._many1 = function (x) {
    return this._many(x, x.call(this));
  };
  OMeta.prototype._form = function (x) {
    var origInput, r, v;
    v = this._apply("anything");
    if (!isSequenceable(v)) {
      throw this.fail;
    }
    origInput = this.input;
    this.input = ListOMInputStream.toStream(v);
    r = x.call(this);
    this._apply("end");
    this.input = origInput;
    return v;
  };
  OMeta.prototype._consumedBy = function (x) {
    var origInput;
    origInput = this.input;
    x.call(this);
    return origInput.upTo(this.input);
  };
  OMeta.prototype._idxConsumedBy = function (x) {
    var origInput;
    origInput = this.input;
    x.call(this);
    return [
      origInput.idx,
      this.input.idx
    ];
  };
  OMeta.prototype._interleave = function (mode1, part1, mode2, part2) {
    var allDone, ans, arg, currInput, idx, _i, _len;
    currInput = this.input;
    ans = [];
    for (idx = _i = 0, _len = arguments.length; _i < _len; idx = _i += 2) {
      arg = arguments[idx];
      ans[idx / 2] = arg === "*" || arg === "+" ? [] : void 0;
    }
    while (true) {
      idx = 0;
      allDone = true;
      while (idx < arguments.length) {
        if (arguments[idx] !== "0") {
          try {
            this.input = currInput;
            switch (arguments[idx]) {
            case "*":
              ans[idx / 2].push(arguments[idx + 1].call(this));
              break;
            case "+":
              ans[idx / 2].push(arguments[idx + 1].call(this));
              arguments[idx] = "*";
              break;
            case "?":
              ans[idx / 2] = arguments[idx + 1].call(this);
              arguments[idx] = "0";
              break;
            case "1":
              ans[idx / 2] = arguments[idx + 1].call(this);
              arguments[idx] = "0";
              break;
            default:
              throw "invalid mode '" + arguments[idx] + "' in OMeta._interleave";
            }
            currInput = this.input;
            break;
          } catch (f) {
            if (f !== this.fail) {
              throw f;
            }
            allDone = allDone && (arguments[idx] === "*" || arguments[idx] === "?");
          }
        }
        idx += 2;
      }
      if (idx === arguments.length) {
        if (allDone) {
          return ans;
        } else {
          throw this.fail;
        }
      }
    }
  };
  OMeta.prototype._currIdx = function () {
    return this.input.idx;
  };
  OMeta.prototype.anything = function () {
    var r;
    r = this.input.head();
    this.input = this.input.tail();
    return r;
  };
  OMeta.prototype.end = function () {
    return this._not(function () {
      return this._apply("anything");
    });
  };
  OMeta.prototype.pos = function () {
    return this.input.idx;
  };
  OMeta.prototype.empty = function () {
    return true;
  };
  OMeta.prototype.apply = function (r) {
    return this._apply(r);
  };
  OMeta.prototype.foreign = function (g, r) {
    var ans, gi;
    gi = new g(makeOMInputStreamProxy(this.input));
    ans = gi._apply(r);
    this.input = gi.input.target;
    return ans;
  };
  OMeta.prototype.exactly = function (wanted) {
    if (wanted === this._apply("anything")) {
      return wanted;
    }
    throw this.fail;
  };
  OMeta.prototype["true"] = function () {
    var r;
    r = this._apply("anything");
    this._pred(r === true);
    return r;
  };
  OMeta.prototype["false"] = function () {
    var r;
    r = this._apply("anything");
    this._pred(r === false);
    return r;
  };
  OMeta.prototype.undefined = function () {
    var r;
    r = this._apply("anything");
    this._pred(r === void 0);
    return r;
  };
  OMeta.prototype.number = function () {
    var r;
    r = this._apply("anything");
    this._pred(typeof r === "number");
    return r;
  };
  OMeta.prototype.string = function () {
    var r;
    r = this._apply("anything");
    this._pred(typeof r === "string");
    return r;
  };
  OMeta.prototype.char = function () {
    var r;
    r = this._apply("anything");
    this._pred(typeof r === "string" && r.length === 1);
    return r;
  };
  OMeta.prototype.space = function () {
    var r;
    r = this._apply("char");
    this._pred(r.charCodeAt(0) <= 32);
    return r;
  };
  OMeta.prototype.spaces = function () {
    return this._many(function () {
      return this._apply("space");
    });
  };
  OMeta.prototype.digit = function () {
    var r;
    r = this._apply("char");
    this._pred(r >= "0" && r <= "9");
    return r;
  };
  OMeta.prototype.lower = function () {
    var r;
    r = this._apply("char");
    this._pred(r >= "a" && r <= "z");
    return r;
  };
  OMeta.prototype.upper = function () {
    var r;
    r = this._apply("char");
    this._pred(r >= "A" && r <= "Z");
    return r;
  };
  OMeta.prototype.letter = function () {
    return this._or(function () {
      return this._apply("lower");
    }, function () {
      return this._apply("upper");
    });
  };
  OMeta.prototype.letterOrDigit = function () {
    return this._or(function () {
      return this._apply("letter");
    }, function () {
      return this._apply("digit");
    });
  };
  OMeta.prototype.firstAndRest = function (first, rest) {
    return this._many(function () {
      return this._apply(rest);
    }, this._apply(first));
  };
  OMeta.prototype.seq = function (xs) {
    var x, _i, _len;
    for (_i = 0, _len = xs.length; _i < _len; _i++) {
      x = xs[_i];
      this._applyWithArgs("exactly", x);
    }
    return xs;
  };
  OMeta.prototype.notLast = function (rule) {
    var r;
    r = this._apply(rule);
    this._lookahead(function () {
      return this._apply(rule);
    });
    return r;
  };
  OMeta.prototype.listOf = function (rule, delim) {
    return this._or(function () {
      var r;
      r = this._apply(rule);
      return this._many(function () {
        this._applyWithArgs("token", delim);
        return this._apply(rule);
      }, r);
    }, function () {
      return [];
    });
  };
  OMeta.prototype.token = function (cs) {
    this._apply("spaces");
    return this._applyWithArgs("seq", cs);
  };
  OMeta.prototype.fromTo = function (x, y) {
    return this._consumedBy(function () {
      this._applyWithArgs("seq", x);
      this._many(function () {
        this._not(function () {
          return this._applyWithArgs("seq", y);
        });
        return this._apply("char");
      });
      return this._applyWithArgs("seq", y);
    });
  };
  OMeta.prototype.prepend = function (xs) {
    var i, _i, _ref, _results;
    _results = [];
    for (i = _i = _ref = xs.length - 1; _i >= 0; i = _i += -1) {
      _results.push(this._prependInput(xs[i]));
    }
    return _results;
  };
  OMeta.prototype.initialize = function () {
  };
  OMeta._genericMatch = function (input, rule, args, matchFailed) {
    var arg, m, realArgs, _i, _len;
    if (args == null) {
      args = [];
    }
    realArgs = [rule];
    for (_i = 0, _len = args.length; _i < _len; _i++) {
      arg = args[_i];
      realArgs.push(arg);
    }
    m = new this(input);
    try {
      if (realArgs.length === 1) {
        return m._apply.call(m, realArgs[0]);
      } else {
        return m._applyWithArgs.apply(m, realArgs);
      }
    } catch (f) {
      if (f === this.prototype.fail && matchFailed != null) {
        input = m.input;
        if (input.idx != null) {
          while (input.tl != null && input.tl.idx != null) {
            input = input.tl;
          }
          input.idx--;
        }
        return matchFailed(m, input.idx);
      }
      if (matchFailed != null) {
        console.log("Special error: " + f);
      }
      throw f;
    }
  };
  OMeta.match = function (obj, rule, args, matchFailed) {
    return this._genericMatch(ListOMInputStream.toStream([obj]), rule, args, matchFailed);
  };
  OMeta.matchAll = function (listyObj, rule, args, matchFailed) {
    return this._genericMatch(ListOMInputStream.toStream(listyObj), rule, args, matchFailed);
  };
  return OMeta;
}();

return module.exports;

});
define('ometa-lib',['require','exports','module'],function (require, exports, module) {
  

var Set, Stack, StringBuffer, c, escapeChar, escapeStringFor, extend, key, objectThatDelegatesTo, ownPropertyNames, padStringWith, specials, toProgramString, trim, unescape, val, _i, __hasProp = {}.hasOwnProperty, __extends = function (child, parent) {
    for (var key in parent) {
      if (__hasProp.call(parent, key))
        child[key] = parent[key];
    }
    function ctor() {
      this.constructor = child;
    }
    ctor.prototype = parent.prototype;
    child.prototype = new ctor();
    child.__super__ = parent.prototype;
    return child;
  }, __slice = [].slice;
StringBuffer = function () {
  function StringBuffer() {
    var arg, _i, _len;
    this.strings = [];
    for (_i = 0, _len = arguments.length; _i < _len; _i++) {
      arg = arguments[_i];
      this.nextPutAll(arg);
    }
  }
  StringBuffer.prototype.nextPutAll = function (s) {
    return this.strings.push(s);
  };
  StringBuffer.prototype.contents = function () {
    return this.strings.join("");
  };
  StringBuffer.writeStream = function (string) {
    return new StringBuffer(string);
  };
  return StringBuffer;
}();
objectThatDelegatesTo = function (x, props) {
  var key, sub, val;
  sub = function (_super) {
    __extends(_Class, _super);
    function _Class() {
      return _Class.__super__.constructor.apply(this, arguments);
    }
    return _Class;
  }(x);
  for (key in props) {
    if (!__hasProp.call(props, key))
      continue;
    val = props[key];
    sub.prototype[key] = val;
  }
  return sub;
};
ownPropertyNames = function (x) {
  var key, _results;
  _results = [];
  for (key in x) {
    if (!__hasProp.call(x, key))
      continue;
    _results.push(key);
  }
  return _results;
};
Set = function () {
  function Set() {
    this.data = {};
  }
  Set.prototype.add = function () {
    var one, what, _i, _len;
    what = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
    for (_i = 0, _len = what.length; _i < _len; _i++) {
      one = what[_i];
      this.data[one] = true;
    }
    return this;
  };
  Set.prototype.values = function () {
    var key, _ref, _results;
    _ref = this.data;
    _results = [];
    for (key in _ref) {
      if (!__hasProp.call(_ref, key))
        continue;
      _results.push(key);
    }
    return _results;
  };
  return Set;
}();
Stack = function () {
  function Stack() {
    this.data = [];
  }
  Stack.prototype.push = function (v) {
    this.data.push(v);
    return this;
  };
  Stack.prototype.pop = function () {
    this.data = this.data.slice(0, -1);
    return this;
  };
  Stack.prototype.top = function () {
    return this.data.slice(-1)[0];
  };
  return Stack;
}();
trim = function (str) {
  var i, ws;
  str = str.replace(/^\s\s*/, "");
  ws = /\s/;
  i = str.length - 1;
  while (ws.test(str.charAt(i))) {
    --i;
  }
  return str.slice(0, +i + 1 || 9000000000);
};
extend = function (a, b) {
  var key, value;
  for (key in b) {
    if (!__hasProp.call(b, key))
      continue;
    value = b[key];
    a[key] = value;
  }
  return a;
};
padStringWith = function (string, s, len) {
  var r;
  r = string;
  while (r.length < len) {
    r = s + r;
  }
  return r;
};
escapeStringFor = new Object();
for (c = _i = 0; _i < 128; c = ++_i) {
  escapeStringFor[c] = String.fromCharCode(c);
}
specials = {
  "'": "\\'",
  "\"": "\\\"",
  "\\": "\\\\",
  "": "\\b",
  "": "\\f",
  "\n": "\\n",
  "\r": "\\r",
  "	": "\\t",
  "": "\\v"
};
for (key in specials) {
  val = specials[key];
  escapeStringFor[key.charCodeAt(0)] = val;
}
escapeChar = function (c) {
  var charCode;
  charCode = c.charCodeAt(0);
  if (charCode < 128) {
    return escapeStringFor[charCode];
  } else if (128 <= charCode && charCode < 256) {
    return "\\x" + padStringWith(charCode.toString(16), "0", 2);
  } else {
    return "\\u" + padStringWith(charCode.toString(16), "0", 4);
  }
};
unescape = function (s) {
  if (s.charAt(0) === "\\") {
    switch (s.charAt(1)) {
    case "'":
      return "'";
    case "\"":
      return "\"";
    case "\\":
      return "\\";
    case "b":
      return "";
    case "f":
      return "";
    case "n":
      return "\n";
    case "r":
      return "\r";
    case "t":
      return "	";
    case "v":
      return "";
    case "x":
      return String.fromCharCode(parseInt(s.substring(2, 4), 16));
    case "u":
      return String.fromCharCode(parseInt(s.substring(2, 6), 16));
    default:
      return s.charAt(1);
    }
  } else {
    return s;
  }
};
toProgramString = function (string) {
  var ch, ws, _j, _len;
  ws = StringBuffer.writeStream("\"");
  for (_j = 0, _len = string.length; _j < _len; _j++) {
    ch = string[_j];
    ws.nextPutAll(escapeChar(ch));
  }
  ws.nextPutAll("\"");
  return ws.contents();
};
module.exports = {
  escapeChar: escapeChar,
  unescape: unescape,
  propertyNames: ownPropertyNames,
  programString: toProgramString,
  subclass: objectThatDelegatesTo,
  StringBuffer: StringBuffer,
  Set: Set,
  Stack: Stack,
  trim: trim,
  extend: extend
};

return module.exports;

});
define('coffee-script',[],function () {
  if (__isNode) {
  return __nodeRequire('coffee-script');
} else {
  return (typeof BSCoffeeScriptCompiler !== 'undefined') ? BSCoffeeScriptCompiler : __nodeRequire('coffee-script')
}
});
define('bs-dentparser',['require', 'exports', 'module', './ometa-base', './ometa-lib'], function (require, exports, module) {
  

var OMeta, Stack, subclass, _ref;
OMeta = require("./ometa-base");
_ref = require("./ometa-lib"), subclass = _ref.subclass, Stack = _ref.Stack;
BSDentParser = subclass(OMeta, {
  "initialize": function () {
    return this.mindent = new Stack().push(-1);
  },
  "exactly": function () {
    var other;
    return this._or(function () {
      return function () {
        switch (this._apply("anything")) {
        case "\n":
          return this._applyWithArgs("apply", "nl");
        default:
          throw this.fail;
        }
      }.call(this);
    }, function () {
      return function () {
        other = this._apply("anything");
        return OMeta._superApplyWithArgs(this, "exactly", other);
      }.call(this);
    });
  },
  "inspace": function () {
    return function () {
      this._not(function () {
        return this._applyWithArgs("exactly", "\n");
      });
      return this._apply("space");
    }.call(this);
  },
  "nl": function () {
    var p;
    return function () {
      OMeta._superApplyWithArgs(this, "exactly", "\n");
      p = this._apply("pos");
      this.lineStart = p;
      return "\n";
    }.call(this);
  },
  "blankLine": function () {
    return function () {
      this._many(function () {
        return this._apply("inspace");
      });
      return this._applyWithArgs("exactly", "\n");
    }.call(this);
  },
  "dent": function () {
    var ss;
    return function () {
      this._many(function () {
        return this._apply("inspace");
      });
      this._applyWithArgs("exactly", "\n");
      this._many(function () {
        return this._apply("blankLine");
      });
      ss = this._many(function () {
        return this._applyWithArgs("exactly", " ");
      });
      return ss.length;
    }.call(this);
  },
  "linePos": function () {
    var p;
    return function () {
      p = this._apply("pos");
      return p - (this.lineStart || 0);
    }.call(this);
  },
  "stripdent": function () {
    var d, p;
    return function () {
      d = this._apply("anything");
      p = this._apply("anything");
      return "\n" + Array(d - p).join(" ");
    }.call(this);
  },
  "nodent": function () {
    var p, d;
    return function () {
      p = this._apply("anything");
      d = this._apply("dent");
      return this._pred(d === p);
    }.call(this);
  },
  "moredent": function () {
    var p, d;
    return function () {
      p = this._apply("anything");
      d = this._apply("dent");
      this._pred(d >= p);
      return this._applyWithArgs("stripdent", d, p);
    }.call(this);
  },
  "lessdent": function () {
    var p, d;
    return function () {
      p = this._apply("anything");
      return this._or(function () {
        return function () {
          d = this._apply("dent");
          return this._pred(d <= p);
        }.call(this);
      }, function () {
        return function () {
          this._many(function () {
            return this._apply("inspace");
          });
          return this._apply("end");
        }.call(this);
      });
    }.call(this);
  },
  "setdent": function () {
    var p;
    return function () {
      p = this._apply("anything");
      return this.mindent.push(p);
    }.call(this);
  },
  "redent": function () {
    return this.mindent.pop();
  },
  "spacedent": function () {
    return function () {
      this._pred(this.mindent.top() >= 0);
      return this._applyWithArgs("moredent", this.mindent.top());
    }.call(this);
  }
});
module.exports = BSDentParser;

return module.exports;

});
define('bs-semactionparser',['require', 'exports', 'module', './ometa-base', './ometa-lib', 'coffee-script', './bs-dentparser'], function (require, exports, module) {
  

var BSCoffeeScriptCompiler, BSDentParser, OMeta, compileAction, subclass, trim, _ref;
OMeta = require("./ometa-base");
_ref = require("./ometa-lib"), subclass = _ref.subclass, trim = _ref.trim;
BSCoffeeScriptCompiler = require("coffee-script");
BSDentParser = require("./bs-dentparser");
compileAction = function (input, args) {
  var compiled, result, wrapped;
  try {
    wrapped = "((" + args.join() + ") ->\n  " + input.replace(/\n/g, "\n  ") + ").call(this)";
    compiled = BSCoffeeScriptCompiler.compile(wrapped, { bare: true });
    result = trim(compiled).replace(/^\s*(var[^]*?)?(\(function[^]*?\{)([^]*)/, "(function(){$1$3").replace(/;$/, "");
  } catch (e) {
    throw "" + input + "\n\n" + e.toString();
  }
  return result;
};
BSCSParser = subclass(OMeta, {
  "action": function () {
    var input, args, compiled;
    return function () {
      input = this._apply("anything");
      args = this._apply("anything");
      compiled = this._applyWithArgs("compile", input, args);
      return this._or(function () {
        return this._applyWithArgs("simplify", compiled);
      }, function () {
        return compiled;
      });
    }.call(this);
  },
  "simpleExp": function () {
    var input, args, compiled;
    return function () {
      input = this._apply("anything");
      args = this._apply("anything");
      compiled = this._applyWithArgs("compile", input, args);
      return this._applyWithArgs("simplify", compiled);
    }.call(this);
  },
  "compile": function () {
    var input, args;
    return function () {
      input = this._apply("anything");
      args = this._apply("anything");
      return compileAction(input, args);
    }.call(this);
  },
  "simplify": function () {
    var compiled;
    return function () {
      compiled = this._apply("anything");
      return function () {
        var exp, lines;
        lines = compiled.split("\n");
        if (lines.length < 2 || !lines[1].match(/^ +return/)) {
          throw this.fail;
        }
        exp = lines.slice(1, -1);
        exp[0] = exp[0].replace(/^ +return /, "");
        return exp.join("\n").replace(/;$/, "");
      }.call(this);
    }.call(this);
  }
});
BSSemActionParser = subclass(BSDentParser, {
  "initialize": function () {
    return function () {
      (function () {
        this.dentlevel = 0;
        return this.sep = "none";
      }.call(this));
      return BSDentParser._superApplyWithArgs(this, "initialize");
    }.call(this);
  },
  "none": function () {
    return this._not(function () {
      return this._apply("empty");
    });
  },
  "comma": function () {
    return this._applyWithArgs("exactly", ",");
  },
  "between": function () {
    var s, e, t;
    return function () {
      s = this._apply("anything");
      e = this._apply("anything");
      this._applyWithArgs("seq", s);
      t = this._applyWithArgs("text", true);
      this._applyWithArgs("seq", e);
      return t;
    }.call(this);
  },
  "pairOf": function () {
    var s, e, t;
    return function () {
      s = this._apply("anything");
      e = this._apply("anything");
      t = this._applyWithArgs("between", s, e);
      return s + t + e;
    }.call(this);
  },
  "delims": function () {
    return function () {
      switch (this._apply("anything")) {
      case "{":
        return "{";
      case "(":
        return "(";
      case "[":
        return "[";
      case "}":
        return "}";
      case ")":
        return ")";
      case "]":
        return "]";
      default:
        throw this.fail;
      }
    }.call(this);
  },
  "pair": function () {
    return this._or(function () {
      return this._applyWithArgs("pairOf", "{", "}");
    }, function () {
      return this._applyWithArgs("pairOf", "(", ")");
    }, function () {
      return this._applyWithArgs("pairOf", "[", "]");
    });
  },
  "text3": function () {
    var d;
    return this._or(function () {
      return function () {
        d = this._apply("dent");
        return this._applyWithArgs("stripdent", d, this.dentlevel);
      }.call(this);
    }, function () {
      return function () {
        this._not(function () {
          return this._applyWithArgs("exactly", "\n");
        });
        return this._apply("anything");
      }.call(this);
    });
  },
  "fromTo": function () {
    var s, e;
    return function () {
      s = this._apply("anything");
      e = this._apply("anything");
      return this._consumedBy(function () {
        return function () {
          this._applyWithArgs("seq", s);
          this._many(function () {
            return this._or(function () {
              return function () {
                switch (this._apply("anything")) {
                case "\\":
                  return this._or(function () {
                    return function () {
                      switch (this._apply("anything")) {
                      case "\\":
                        return "\\\\";
                      default:
                        throw this.fail;
                      }
                    }.call(this);
                  }, function () {
                    return function () {
                      "\\";
                      return this._applyWithArgs("seq", e);
                    }.call(this);
                  });
                default:
                  throw this.fail;
                }
              }.call(this);
            }, function () {
              return function () {
                this._not(function () {
                  return this._applyWithArgs("seq", e);
                });
                return this._apply("char");
              }.call(this);
            });
          });
          return this._applyWithArgs("seq", e);
        }.call(this);
      });
    }.call(this);
  },
  "text2": function () {
    var inside;
    return function () {
      inside = this._apply("anything");
      return this._or(function () {
        return this._applyWithArgs("fromTo", "###", "###");
      }, function () {
        return this._applyWithArgs("fromTo", "\"", "\"");
      }, function () {
        return this._applyWithArgs("fromTo", "'", "'");
      }, function () {
        return this._consumedBy(function () {
          return function () {
            this._applyWithArgs("exactly", "/");
            this._many1(function () {
              return this._or(function () {
                return function () {
                  switch (this._apply("anything")) {
                  case "\\":
                    return this._or(function () {
                      return function () {
                        switch (this._apply("anything")) {
                        case "\\":
                          return "\\\\";
                        default:
                          throw this.fail;
                        }
                      }.call(this);
                    }, function () {
                      return function () {
                        "\\";
                        return this._applyWithArgs("exactly", "/");
                      }.call(this);
                    });
                  default:
                    throw this.fail;
                  }
                }.call(this);
              }, function () {
                return function () {
                  this._not(function () {
                    return this._applyWithArgs("exactly", "\n");
                  });
                  this._not(function () {
                    return this._applyWithArgs("exactly", "/");
                  });
                  return this._apply("char");
                }.call(this);
              });
            });
            return this._applyWithArgs("exactly", "/");
          }.call(this);
        });
      }, function () {
        return function () {
          this._pred(inside);
          this._not(function () {
            return this._apply("delims");
          });
          return this._apply("text3");
        }.call(this);
      }, function () {
        return function () {
          this._not(function () {
            return this._applyWithArgs("exactly", "\n");
          });
          this._not(function () {
            return this._apply("delims");
          });
          this._not(function () {
            return this._applyWithArgs("apply", this.sep);
          });
          return this._apply("anything");
        }.call(this);
      }, function () {
        return this._apply("pair");
      });
    }.call(this);
  },
  "text": function () {
    var inside, ts;
    return function () {
      inside = this._apply("anything");
      ts = this._many(function () {
        return this._applyWithArgs("text2", inside);
      });
      return ts.join("");
    }.call(this);
  },
  "line": function () {
    return this._applyWithArgs("text", false);
  },
  "nextLine": function () {
    var p, d, l;
    return function () {
      p = this._apply("anything");
      d = this._applyWithArgs("moredent", p);
      l = this._apply("line");
      return d + l;
    }.call(this);
  },
  "exp": function () {
    var p, fl, ls;
    return function () {
      p = this._apply("anything");
      fl = this._apply("line");
      ls = this._many(function () {
        return this._applyWithArgs("nextLine", p);
      });
      return fl + ls.join("");
    }.call(this);
  },
  "simpleExp": function () {
    var args, t;
    return function () {
      args = this._apply("anything");
      this._apply("spaces");
      this.sep = "comma";
      t = this._applyWithArgs("text", false);
      return this._applyWithArgs("foreign", BSCSParser, "simpleExp", t, args);
    }.call(this);
  },
  "delimSemAction": function () {
    var args, e;
    return function () {
      args = this._apply("anything");
      this._apply("spaces");
      e = this._applyWithArgs("between", "{", "}");
      return this._applyWithArgs("foreign", BSCSParser, "action", e, args);
    }.call(this);
  },
  "semAction": function () {
    var p, args, e;
    return function () {
      p = this._apply("anything");
      args = this._apply("anything");
      this.dentlevel = p;
      return this._or(function () {
        return this._apply("delimSemAction");
      }, function () {
        return function () {
          this._apply("spaces");
          e = this._applyWithArgs("exp", p);
          return this._applyWithArgs("foreign", BSCSParser, "action", e, args);
        }.call(this);
      });
    }.call(this);
  }
});
module.exports = BSSemActionParser;

return module.exports;

});
define('bs-ometa-optimizer',['require', 'exports', 'module', './ometa-base', './ometa-lib', './bs-ometa-compiler'], function (require, exports, module) {
  

var JumpTable, OMeta, extend, programString, propertyNames, subclass, _ref;
OMeta = require("./ometa-base");
_ref = require("./ometa-lib"), subclass = _ref.subclass, propertyNames = _ref.propertyNames, programString = _ref.programString, extend = _ref.extend;
BSNullOptimization = subclass(OMeta, {
  "setHelped": function () {
    return this._didSomething = true;
  },
  "helped": function () {
    return this._pred(this._didSomething);
  },
  "trans": function () {
    var t, ans;
    return function () {
      this._form(function () {
        return function () {
          t = this._apply("anything");
          this._pred(this[t] != null);
          return ans = this._applyWithArgs("apply", t);
        }.call(this);
      });
      return ans;
    }.call(this);
  },
  "optimize": function () {
    var x;
    return function () {
      x = this._apply("trans");
      this._apply("helped");
      return x;
    }.call(this);
  },
  "App": function () {
    var rule, args;
    return function () {
      rule = this._apply("anything");
      args = this._many(function () {
        return this._apply("anything");
      });
      return [
        "App",
        rule
      ].concat(args);
    }.call(this);
  },
  "Act": function () {
    var expr;
    return function () {
      expr = this._apply("anything");
      return [
        "Act",
        expr
      ];
    }.call(this);
  },
  "Pred": function () {
    var expr;
    return function () {
      expr = this._apply("anything");
      return [
        "Pred",
        expr
      ];
    }.call(this);
  },
  "Or": function () {
    var xs;
    return function () {
      xs = this._many(function () {
        return this._apply("trans");
      });
      return ["Or"].concat(xs);
    }.call(this);
  },
  "XOr": function () {
    var xs;
    return function () {
      xs = this._many(function () {
        return this._apply("trans");
      });
      return ["XOr"].concat(xs);
    }.call(this);
  },
  "And": function () {
    var xs;
    return function () {
      xs = this._many(function () {
        return this._apply("trans");
      });
      return ["And"].concat(xs);
    }.call(this);
  },
  "Opt": function () {
    var x;
    return function () {
      x = this._apply("trans");
      return [
        "Opt",
        x
      ];
    }.call(this);
  },
  "Many": function () {
    var x;
    return function () {
      x = this._apply("trans");
      return [
        "Many",
        x
      ];
    }.call(this);
  },
  "Many1": function () {
    var x;
    return function () {
      x = this._apply("trans");
      return [
        "Many1",
        x
      ];
    }.call(this);
  },
  "Set": function () {
    var n, v;
    return function () {
      n = this._apply("anything");
      v = this._apply("trans");
      return [
        "Set",
        n,
        v
      ];
    }.call(this);
  },
  "Not": function () {
    var x;
    return function () {
      x = this._apply("trans");
      return [
        "Not",
        x
      ];
    }.call(this);
  },
  "Lookahead": function () {
    var x;
    return function () {
      x = this._apply("trans");
      return [
        "Lookahead",
        x
      ];
    }.call(this);
  },
  "Form": function () {
    var x;
    return function () {
      x = this._apply("trans");
      return [
        "Form",
        x
      ];
    }.call(this);
  },
  "ConsBy": function () {
    var x;
    return function () {
      x = this._apply("trans");
      return [
        "ConsBy",
        x
      ];
    }.call(this);
  },
  "IdxConsBy": function () {
    var x;
    return function () {
      x = this._apply("trans");
      return [
        "IdxConsBy",
        x
      ];
    }.call(this);
  },
  "JumpTable": function () {
    var c, e, ces;
    return function () {
      ces = this._many(function () {
        return function () {
          this._form(function () {
            return function () {
              c = this._apply("anything");
              return e = this._apply("trans");
            }.call(this);
          });
          return [
            c,
            e
          ];
        }.call(this);
      });
      return ["JumpTable"].concat(ces);
    }.call(this);
  },
  "Interleave": function () {
    var m, p, xs;
    return function () {
      xs = this._many(function () {
        return function () {
          this._form(function () {
            return function () {
              m = this._apply("anything");
              return p = this._apply("trans");
            }.call(this);
          });
          return [
            m,
            p
          ];
        }.call(this);
      });
      return ["Interleave"].concat(xs);
    }.call(this);
  },
  "Rule": function () {
    var name, ls, body;
    return function () {
      name = this._apply("anything");
      ls = this._apply("anything");
      body = this._apply("trans");
      return [
        "Rule",
        name,
        ls,
        body
      ];
    }.call(this);
  },
  "initialize": function () {
    return this._didSomething = false;
  }
});
BSAssociativeOptimization = subclass(BSNullOptimization, {
  "And": function () {
    var x, xs;
    return this._or(function () {
      return function () {
        x = this._apply("trans");
        this._apply("end");
        this._apply("setHelped");
        return x;
      }.call(this);
    }, function () {
      return function () {
        xs = this._applyWithArgs("transInside", "And");
        return ["And"].concat(xs);
      }.call(this);
    });
  },
  "Or": function () {
    var x, xs;
    return this._or(function () {
      return function () {
        x = this._apply("trans");
        this._apply("end");
        this._apply("setHelped");
        return x;
      }.call(this);
    }, function () {
      return function () {
        xs = this._applyWithArgs("transInside", "Or");
        return ["Or"].concat(xs);
      }.call(this);
    });
  },
  "XOr": function () {
    var x, xs;
    return this._or(function () {
      return function () {
        x = this._apply("trans");
        this._apply("end");
        this._apply("setHelped");
        return x;
      }.call(this);
    }, function () {
      return function () {
        xs = this._applyWithArgs("transInside", "XOr");
        return ["XOr"].concat(xs);
      }.call(this);
    });
  },
  "transInside": function () {
    var t, xs, ys, x;
    return function () {
      t = this._apply("anything");
      return this._or(function () {
        return function () {
          this._form(function () {
            return function () {
              this._applyWithArgs("exactly", t);
              return xs = this._applyWithArgs("transInside", t);
            }.call(this);
          });
          ys = this._applyWithArgs("transInside", t);
          this._apply("setHelped");
          return xs.concat(ys);
        }.call(this);
      }, function () {
        return function () {
          x = this._apply("trans");
          xs = this._applyWithArgs("transInside", t);
          return [x].concat(xs);
        }.call(this);
      }, function () {
        return [];
      });
    }.call(this);
  }
});
BSSeqInliner = subclass(BSNullOptimization, {
  "App": function () {
    var s, cs, rule, args;
    return this._or(function () {
      return function () {
        switch (this._apply("anything")) {
        case "seq":
          return function () {
            s = this._apply("anything");
            this._apply("end");
            cs = this._applyWithArgs("seqString", s);
            this._apply("setHelped");
            return ["And"].concat(cs).concat([[
                "Act",
                s
              ]]);
          }.call(this);
        default:
          throw this.fail;
        }
      }.call(this);
    }, function () {
      return function () {
        rule = this._apply("anything");
        args = this._many(function () {
          return this._apply("anything");
        });
        return [
          "App",
          rule
        ].concat(args);
      }.call(this);
    });
  },
  "inlineChar": function () {
    var BSOMetaParser, c;
    return function () {
      BSOMetaParser = require("./bs-ometa-compiler").BSOMetaParser;
      c = this._applyWithArgs("foreign", BSOMetaParser, "escapedChar");
      this._not(function () {
        return this._apply("end");
      });
      return [
        "App",
        "exactly",
        programString(c)
      ];
    }.call(this);
  },
  "seqString": function () {
    var s, cs;
    return function () {
      this._lookahead(function () {
        return function () {
          s = this._apply("anything");
          return this._pred(typeof s === "string");
        }.call(this);
      });
      return this._or(function () {
        return function () {
          this._form(function () {
            return function () {
              this._applyWithArgs("exactly", "\"");
              cs = this._many(function () {
                return this._apply("inlineChar");
              });
              return this._applyWithArgs("exactly", "\"");
            }.call(this);
          });
          return cs;
        }.call(this);
      }, function () {
        return function () {
          this._form(function () {
            return function () {
              this._applyWithArgs("exactly", "'");
              cs = this._many(function () {
                return this._apply("inlineChar");
              });
              return this._applyWithArgs("exactly", "'");
            }.call(this);
          });
          return cs;
        }.call(this);
      });
    }.call(this);
  }
});
JumpTable = function () {
  function JumpTable(choiceOp, choice) {
    this.choiceOp = choiceOp;
    this.choices = {};
    this.add(choice);
    return;
  }
  JumpTable.prototype.add = function (choice) {
    var c, t;
    c = choice[0], t = choice[1];
    if (this.choices[c]) {
      if (this.choices[c][0] === this.choiceOp) {
        this.choices[c].push(t);
      } else {
        this.choices[c] = [
          this.choiceOp,
          this.choices[c],
          t
        ];
      }
    } else {
      this.choices[c] = t;
    }
  };
  JumpTable.prototype.toTree = function () {
    var choiceKey, choiceKeys, r, _i, _len;
    r = ["JumpTable"];
    choiceKeys = propertyNames(this.choices);
    for (_i = 0, _len = choiceKeys.length; _i < _len; _i++) {
      choiceKey = choiceKeys[_i];
      r.push([
        choiceKey,
        this.choices[choiceKey]
      ]);
    }
    return r;
  };
  return JumpTable;
}();
BSJumpTableOptimization = subclass(BSNullOptimization, {
  "Or": function () {
    var cs;
    return function () {
      cs = this._many(function () {
        return this._or(function () {
          return this._applyWithArgs("jtChoices", "Or");
        }, function () {
          return this._apply("trans");
        });
      });
      return ["Or"].concat(cs);
    }.call(this);
  },
  "XOr": function () {
    var cs;
    return function () {
      cs = this._many(function () {
        return this._or(function () {
          return this._applyWithArgs("jtChoices", "XOr");
        }, function () {
          return this._apply("trans");
        });
      });
      return ["XOr"].concat(cs);
    }.call(this);
  },
  "quotedString": function () {
    var BSOMetaParser, c, cs;
    return function () {
      BSOMetaParser = require("./bs-ometa-compiler").BSOMetaParser;
      this._lookahead(function () {
        return this._apply("string");
      });
      this._form(function () {
        return function () {
          switch (this._apply("anything")) {
          case "\"":
            return function () {
              cs = this._many(function () {
                return function () {
                  c = this._applyWithArgs("foreign", BSOMetaParser, "escapedChar");
                  this._not(function () {
                    return this._apply("end");
                  });
                  return c;
                }.call(this);
              });
              return this._applyWithArgs("exactly", "\"");
            }.call(this);
          case "'":
            return function () {
              cs = this._many(function () {
                return function () {
                  c = this._applyWithArgs("foreign", BSOMetaParser, "escapedChar");
                  this._not(function () {
                    return this._apply("end");
                  });
                  return c;
                }.call(this);
              });
              return this._applyWithArgs("exactly", "'");
            }.call(this);
          default:
            throw this.fail;
          }
        }.call(this);
      });
      return cs.join("");
    }.call(this);
  },
  "jtChoice": function () {
    var x, rest;
    return this._or(function () {
      return function () {
        this._form(function () {
          return function () {
            this._applyWithArgs("exactly", "And");
            this._form(function () {
              return function () {
                this._applyWithArgs("exactly", "App");
                this._applyWithArgs("exactly", "exactly");
                return x = this._apply("quotedString");
              }.call(this);
            });
            return rest = this._many(function () {
              return this._apply("anything");
            });
          }.call(this);
        });
        return [
          x,
          ["And"].concat(rest)
        ];
      }.call(this);
    }, function () {
      return function () {
        this._form(function () {
          return function () {
            this._applyWithArgs("exactly", "App");
            this._applyWithArgs("exactly", "exactly");
            return x = this._apply("quotedString");
          }.call(this);
        });
        return [
          x,
          [
            "Act",
            programString(x)
          ]
        ];
      }.call(this);
    });
  },
  "jtChoices": function () {
    var op, c, jt;
    return function () {
      op = this._apply("anything");
      c = this._apply("jtChoice");
      jt = new JumpTable(op, c);
      this._many(function () {
        return function () {
          c = this._apply("jtChoice");
          return jt.add(c);
        }.call(this);
      });
      this._apply("setHelped");
      return jt.toTree();
    }.call(this);
  }
});
BSOMetaOptimizer = subclass(OMeta, {
  "optimizeGrammar": function () {
    var n, sn, rs;
    return function () {
      this._form(function () {
        return function () {
          this._applyWithArgs("exactly", "Grammar");
          n = this._apply("anything");
          sn = this._apply("anything");
          return rs = this._many(function () {
            return this._apply("optimizeRule");
          });
        }.call(this);
      });
      return [
        "Grammar",
        n,
        sn
      ].concat(rs);
    }.call(this);
  },
  "optimizeRule": function () {
    var r;
    return function () {
      r = this._apply("anything");
      this._or(function () {
        return r = this._applyWithArgs("foreign", BSSeqInliner, "optimize", r);
      }, function () {
        return this._apply("empty");
      });
      this._many(function () {
        return this._or(function () {
          return r = this._applyWithArgs("foreign", BSAssociativeOptimization, "optimize", r);
        }, function () {
          return r = this._applyWithArgs("foreign", BSJumpTableOptimization, "optimize", r);
        });
      });
      return r;
    }.call(this);
  }
});
module.exports = BSOMetaOptimizer;

return module.exports;

});
define('bs-ometa-compiler',['require', 'exports', 'module', './ometa-base', './ometa-lib', './bs-dentparser', './bs-semactionparser', './bs-ometa-optimizer'], function (require, exports, module) {
  

var BSDentParser, BSOMetaOptimizer, BSSemActionParser, OMeta, Set, programString, propertyNames, subclass, unescape, _ref;
OMeta = require("./ometa-base");
_ref = require("./ometa-lib"), subclass = _ref.subclass, propertyNames = _ref.propertyNames, unescape = _ref.unescape, programString = _ref.programString, Set = _ref.Set;
BSDentParser = require("./bs-dentparser");
BSSemActionParser = require("./bs-semactionparser");
BSOMetaOptimizer = require("./bs-ometa-optimizer");
BSOMetaParser = subclass(BSDentParser, {
  "lineComment": function () {
    return this._applyWithArgs("fromTo", "# ", "\n");
  },
  "blockComment": function () {
    return this._applyWithArgs("fromTo", "#>", "<#");
  },
  "space": function () {
    return this._or(function () {
      return function () {
        switch (this._apply("anything")) {
        case " ":
          return " ";
        default:
          throw this.fail;
        }
      }.call(this);
    }, function () {
      return this._apply("spacedent");
    }, function () {
      return this._apply("lineComment");
    }, function () {
      return this._apply("blockComment");
    });
  },
  "blankLine": function () {
    return this._or(function () {
      return function () {
        this._many(function () {
          return this._applyWithArgs("exactly", " ");
        });
        return this._or(function () {
          return this._apply("lineComment");
        }, function () {
          return function () {
            this._apply("blockComment");
            this._many(function () {
              return this._applyWithArgs("exactly", " ");
            });
            return this._applyWithArgs("exactly", "\n");
          }.call(this);
        });
      }.call(this);
    }, function () {
      return BSDentParser._superApplyWithArgs(this, "blankLine");
    });
  },
  "nameFirst": function () {
    return this._or(function () {
      return function () {
        switch (this._apply("anything")) {
        case "_":
          return "_";
        case "$":
          return "$";
        default:
          throw this.fail;
        }
      }.call(this);
    }, function () {
      return this._apply("letter");
    });
  },
  "bareName": function () {
    return this._consumedBy(function () {
      return function () {
        this._apply("nameFirst");
        return this._many(function () {
          return this._or(function () {
            return this._apply("nameFirst");
          }, function () {
            return this._apply("digit");
          });
        });
      }.call(this);
    });
  },
  "name": function () {
    return function () {
      this._apply("spaces");
      return this._apply("bareName");
    }.call(this);
  },
  "hexValue": function () {
    var ch;
    return function () {
      ch = this._apply("anything");
      return "0123456789abcdef".indexOf(ch.toLowerCase());
    }.call(this);
  },
  "hexDigit": function () {
    var x, v;
    return function () {
      x = this._apply("char");
      v = this._applyWithArgs("hexValue", x);
      this._pred(v >= 0);
      return v;
    }.call(this);
  },
  "escapedChar": function () {
    var s;
    return this._or(function () {
      return function () {
        s = this._consumedBy(function () {
          return function () {
            this._applyWithArgs("exactly", "\\");
            return this._or(function () {
              return function () {
                switch (this._apply("anything")) {
                case "u":
                  return function () {
                    this._apply("hexDigit");
                    this._apply("hexDigit");
                    this._apply("hexDigit");
                    return this._apply("hexDigit");
                  }.call(this);
                case "x":
                  return function () {
                    this._apply("hexDigit");
                    return this._apply("hexDigit");
                  }.call(this);
                default:
                  throw this.fail;
                }
              }.call(this);
            }, function () {
              return this._apply("char");
            });
          }.call(this);
        });
        return unescape(s);
      }.call(this);
    }, function () {
      return this._apply("char");
    });
  },
  "charSequence": function () {
    var xs;
    return function () {
      this._applyWithArgs("exactly", "\"");
      xs = this._many(function () {
        return function () {
          this._not(function () {
            return this._applyWithArgs("exactly", "\"");
          });
          return this._apply("escapedChar");
        }.call(this);
      });
      this._applyWithArgs("exactly", "\"");
      return [
        "App",
        "token",
        programString(xs.join(""))
      ];
    }.call(this);
  },
  "string": function () {
    var xs;
    return function () {
      this._applyWithArgs("exactly", "'");
      xs = this._many(function () {
        return function () {
          this._not(function () {
            return this._applyWithArgs("exactly", "'");
          });
          return this._apply("escapedChar");
        }.call(this);
      });
      this._applyWithArgs("exactly", "'");
      return [
        "App",
        "exactly",
        programString(xs.join(""))
      ];
    }.call(this);
  },
  "number": function () {
    var n;
    return function () {
      n = this._consumedBy(function () {
        return function () {
          this._opt(function () {
            return this._applyWithArgs("exactly", "-");
          });
          return this._many1(function () {
            return this._apply("digit");
          });
        }.call(this);
      });
      return [
        "App",
        "exactly",
        n
      ];
    }.call(this);
  },
  "keyword": function () {
    var xs;
    return function () {
      xs = this._apply("anything");
      this._applyWithArgs("token", xs);
      this._not(function () {
        return this._apply("letterOrDigit");
      });
      return xs;
    }.call(this);
  },
  "args": function () {
    var xs;
    return this._or(function () {
      return function () {
        switch (this._apply("anything")) {
        case "(":
          return function () {
            xs = this._applyWithArgs("listOf", "hostExpr", ",");
            this._applyWithArgs("token", ")");
            return xs;
          }.call(this);
        default:
          throw this.fail;
        }
      }.call(this);
    }, function () {
      return function () {
        this._apply("empty");
        return [];
      }.call(this);
    });
  },
  "application": function () {
    var rule, as, grm;
    return this._or(function () {
      return function () {
        this._applyWithArgs("token", "^");
        rule = this._apply("name");
        as = this._apply("args");
        return [
          "App",
          "super",
          "'" + rule + "'"
        ].concat(as);
      }.call(this);
    }, function () {
      return function () {
        grm = this._apply("name");
        this._applyWithArgs("token", ".");
        rule = this._apply("name");
        as = this._apply("args");
        return [
          "App",
          "foreign",
          grm,
          "'" + rule + "'"
        ].concat(as);
      }.call(this);
    }, function () {
      return function () {
        rule = this._apply("name");
        as = this._apply("args");
        return [
          "App",
          rule
        ].concat(as);
      }.call(this);
    });
  },
  "hostExpr": function () {
    return this._applyWithArgs("foreign", BSSemActionParser, "simpleExp", this.locals.values());
  },
  "closedHostExpr": function () {
    return this._applyWithArgs("foreign", BSSemActionParser, "delimSemAction", this.locals.values());
  },
  "openHostExpr": function () {
    var p;
    return function () {
      p = this._apply("anything");
      return this._applyWithArgs("foreign", BSSemActionParser, "semAction", p, this.locals.values());
    }.call(this);
  },
  "semAction": function () {
    var x;
    return function () {
      x = this._apply("closedHostExpr");
      return [
        "Act",
        x
      ];
    }.call(this);
  },
  "arrSemAction": function () {
    var p, x;
    return function () {
      this._applyWithArgs("token", "->");
      p = this._apply("linePos");
      x = this._applyWithArgs("openHostExpr", p);
      return [
        "Act",
        x
      ];
    }.call(this);
  },
  "semPred": function () {
    var x;
    return this._or(function () {
      return function () {
        this._applyWithArgs("token", "&");
        x = this._apply("closedHostExpr");
        return [
          "Pred",
          x
        ];
      }.call(this);
    }, function () {
      return function () {
        this._applyWithArgs("token", "!");
        x = this._apply("closedHostExpr");
        return [
          "Not",
          [
            "Pred",
            x
          ]
        ];
      }.call(this);
    });
  },
  "expr": function () {
    var p, x;
    return function () {
      p = this._apply("anything");
      this._applyWithArgs("setdent", p);
      x = this._apply("expr5");
      this.redent();
      return x;
    }.call(this);
  },
  "expr5": function () {
    var x, xs;
    return this._or(function () {
      return function () {
        x = this._applyWithArgs("expr4", true);
        xs = this._many1(function () {
          return function () {
            this._applyWithArgs("token", "|");
            return this._applyWithArgs("expr4", true);
          }.call(this);
        });
        return [
          "Or",
          x
        ].concat(xs);
      }.call(this);
    }, function () {
      return function () {
        x = this._applyWithArgs("expr4", true);
        xs = this._many1(function () {
          return function () {
            this._applyWithArgs("token", "||");
            return this._applyWithArgs("expr4", true);
          }.call(this);
        });
        return [
          "XOr",
          x
        ].concat(xs);
      }.call(this);
    }, function () {
      return this._applyWithArgs("expr4", false);
    });
  },
  "expr4": function () {
    var ne, xs, act;
    return function () {
      ne = this._apply("anything");
      return this._or(function () {
        return function () {
          xs = this._many(function () {
            return this._apply("expr3");
          });
          act = this._apply("arrSemAction");
          return ["And"].concat(xs).concat([act]);
        }.call(this);
      }, function () {
        return function () {
          this._pred(ne);
          xs = this._many1(function () {
            return this._apply("expr3");
          });
          return ["And"].concat(xs);
        }.call(this);
      }, function () {
        return function () {
          this._not(function () {
            return this._pred(ne);
          });
          xs = this._many(function () {
            return this._apply("expr3");
          });
          return ["And"].concat(xs);
        }.call(this);
      });
    }.call(this);
  },
  "optIter": function () {
    var x;
    return function () {
      x = this._apply("anything");
      return this._or(function () {
        return function () {
          switch (this._apply("anything")) {
          case "*":
            return [
              "Many",
              x
            ];
          case "+":
            return [
              "Many1",
              x
            ];
          case "?":
            return [
              "Opt",
              x
            ];
          default:
            throw this.fail;
          }
        }.call(this);
      }, function () {
        return function () {
          this._apply("empty");
          return x;
        }.call(this);
      });
    }.call(this);
  },
  "optBind": function () {
    var x, n;
    return function () {
      x = this._apply("anything");
      return this._or(function () {
        return function () {
          switch (this._apply("anything")) {
          case ":":
            return function () {
              n = this._apply("name");
              return function () {
                this.locals.add(n);
                return [
                  "Set",
                  n,
                  x
                ];
              }.call(this);
            }.call(this);
          default:
            throw this.fail;
          }
        }.call(this);
      }, function () {
        return function () {
          this._apply("empty");
          return x;
        }.call(this);
      });
    }.call(this);
  },
  "expr3": function () {
    var n, x, e;
    return this._or(function () {
      return function () {
        this._applyWithArgs("token", ":");
        n = this._apply("name");
        return function () {
          this.locals.add(n);
          return [
            "Set",
            n,
            [
              "App",
              "anything"
            ]
          ];
        }.call(this);
      }.call(this);
    }, function () {
      return function () {
        e = this._or(function () {
          return function () {
            x = this._apply("expr2");
            return this._applyWithArgs("optIter", x);
          }.call(this);
        }, function () {
          return this._apply("semAction");
        });
        return this._applyWithArgs("optBind", e);
      }.call(this);
    }, function () {
      return this._apply("semPred");
    });
  },
  "expr2": function () {
    var x;
    return this._or(function () {
      return function () {
        this._applyWithArgs("token", "!");
        x = this._apply("expr2");
        return [
          "Not",
          x
        ];
      }.call(this);
    }, function () {
      return function () {
        this._applyWithArgs("token", "&");
        x = this._apply("expr1");
        return [
          "Lookahead",
          x
        ];
      }.call(this);
    }, function () {
      return this._apply("expr1");
    });
  },
  "expr1": function () {
    var x;
    return this._or(function () {
      return this._apply("application");
    }, function () {
      return function () {
        x = this._or(function () {
          return this._applyWithArgs("keyword", "undefined");
        }, function () {
          return this._applyWithArgs("keyword", "nil");
        }, function () {
          return this._applyWithArgs("keyword", "true");
        }, function () {
          return this._applyWithArgs("keyword", "false");
        });
        return [
          "App",
          "exactly",
          x
        ];
      }.call(this);
    }, function () {
      return function () {
        this._apply("spaces");
        return this._or(function () {
          return this._apply("charSequence");
        }, function () {
          return this._apply("string");
        }, function () {
          return this._apply("number");
        });
      }.call(this);
    }, function () {
      return function () {
        this._applyWithArgs("token", "[");
        x = this._applyWithArgs("expr", 0);
        this._applyWithArgs("token", "]");
        return [
          "Form",
          x
        ];
      }.call(this);
    }, function () {
      return function () {
        this._applyWithArgs("token", "<");
        x = this._applyWithArgs("expr", 0);
        this._applyWithArgs("token", ">");
        return [
          "ConsBy",
          x
        ];
      }.call(this);
    }, function () {
      return function () {
        this._applyWithArgs("token", "@<");
        x = this._applyWithArgs("expr", 0);
        this._applyWithArgs("token", ">");
        return [
          "IdxConsBy",
          x
        ];
      }.call(this);
    }, function () {
      return function () {
        this._applyWithArgs("token", "(");
        x = this._applyWithArgs("expr", 0);
        this._applyWithArgs("token", ")");
        return x;
      }.call(this);
    });
  },
  "ruleName": function () {
    return this._apply("bareName");
  },
  "rule": function () {
    var n, p, x, xs;
    return function () {
      this._lookahead(function () {
        return n = this._apply("ruleName");
      });
      this.locals = new Set();
      p = this._apply("linePos");
      this._applyWithArgs("setdent", p + 1);
      x = this._applyWithArgs("rulePart", n);
      xs = this._many(function () {
        return function () {
          this._applyWithArgs("nodent", p);
          return this._applyWithArgs("rulePart", n);
        }.call(this);
      });
      this.redent();
      return [
        "Rule",
        n,
        this.locals.values(),
        [
          "Or",
          x
        ].concat(xs)
      ];
    }.call(this);
  },
  "rulePart": function () {
    var rn, n, b1, p, b2;
    return function () {
      rn = this._apply("anything");
      n = this._apply("ruleName");
      this._pred(n === rn);
      b1 = this._applyWithArgs("expr4", false);
      return this._or(function () {
        return function () {
          this._apply("spaces");
          p = this._apply("linePos");
          this._applyWithArgs("exactly", "=");
          b2 = this._applyWithArgs("expr", p);
          return [
            "And",
            b1,
            b2
          ];
        }.call(this);
      }, function () {
        return function () {
          this._apply("empty");
          return b1;
        }.call(this);
      });
    }.call(this);
  },
  "grammar": function () {
    var ss, ip, n, sn, p, r, rs;
    return function () {
      ip = function () {
        ss = this._many(function () {
          return this._apply("inspace");
        });
        return 1 + ss.length;
      }.call(this);
      this._applyWithArgs("keyword", "ometa");
      n = this._apply("name");
      sn = this._or(function () {
        return function () {
          this._applyWithArgs("keyword", "extends");
          return this._apply("name");
        }.call(this);
      }, function () {
        return function () {
          this._apply("empty");
          return "OMeta";
        }.call(this);
      });
      this._applyWithArgs("moredent", ip);
      p = this._apply("linePos");
      r = this._apply("rule");
      rs = this._many(function () {
        return function () {
          this._applyWithArgs("nodent", p);
          return this._apply("rule");
        }.call(this);
      });
      return this._applyWithArgs("foreign", BSOMetaOptimizer, "optimizeGrammar", [
        "Grammar",
        n,
        sn,
        r
      ].concat(rs));
    }.call(this);
  }
});
BSOMetaTranslator = subclass(OMeta, {
  "App": function () {
    var args, rule;
    return this._or(function () {
      return function () {
        switch (this._apply("anything")) {
        case "super":
          return function () {
            args = this._many1(function () {
              return this._apply("anything");
            });
            return [
              this.sName,
              "._superApplyWithArgs(this,",
              args.join(),
              ")"
            ].join("");
          }.call(this);
        default:
          throw this.fail;
        }
      }.call(this);
    }, function () {
      return function () {
        rule = this._apply("anything");
        args = this._many1(function () {
          return this._apply("anything");
        });
        return [
          "this._applyWithArgs(\"",
          rule,
          "\",",
          args.join(),
          ")"
        ].join("");
      }.call(this);
    }, function () {
      return function () {
        rule = this._apply("anything");
        return [
          "this._apply(\"",
          rule,
          "\")"
        ].join("");
      }.call(this);
    });
  },
  "Act": function () {
    var expr;
    return function () {
      expr = this._apply("anything");
      return expr;
    }.call(this);
  },
  "Pred": function () {
    var expr;
    return function () {
      expr = this._apply("anything");
      return [
        "this._pred(",
        expr,
        ")"
      ].join("");
    }.call(this);
  },
  "Or": function () {
    var xs;
    return function () {
      xs = this._many(function () {
        return this._apply("transFn");
      });
      return [
        "this._or(",
        xs.join(),
        ")"
      ].join("");
    }.call(this);
  },
  "XOr": function () {
    var xs;
    return function () {
      xs = this._many(function () {
        return this._apply("transFn");
      });
      xs.unshift(programString(this.name + "." + this.rName));
      return [
        "this._xor(",
        xs.join(),
        ")"
      ].join("");
    }.call(this);
  },
  "And": function () {
    var xs, y;
    return this._or(function () {
      return function () {
        xs = this._many(function () {
          return this._applyWithArgs("notLast", "trans");
        });
        y = this._apply("trans");
        xs.push("return " + y);
        return [
          "(function(){",
          xs.join(";"),
          "}).call(this)"
        ].join("");
      }.call(this);
    }, function () {
      return "undefined";
    });
  },
  "Opt": function () {
    var x;
    return function () {
      x = this._apply("transFn");
      return [
        "this._opt(",
        x,
        ")"
      ].join("");
    }.call(this);
  },
  "Many": function () {
    var x;
    return function () {
      x = this._apply("transFn");
      return [
        "this._many(",
        x,
        ")"
      ].join("");
    }.call(this);
  },
  "Many1": function () {
    var x;
    return function () {
      x = this._apply("transFn");
      return [
        "this._many1(",
        x,
        ")"
      ].join("");
    }.call(this);
  },
  "Set": function () {
    var n, v;
    return function () {
      n = this._apply("anything");
      v = this._apply("trans");
      return [
        n,
        "=",
        v
      ].join("");
    }.call(this);
  },
  "Not": function () {
    var x;
    return function () {
      x = this._apply("transFn");
      return [
        "this._not(",
        x,
        ")"
      ].join("");
    }.call(this);
  },
  "Lookahead": function () {
    var x;
    return function () {
      x = this._apply("transFn");
      return [
        "this._lookahead(",
        x,
        ")"
      ].join("");
    }.call(this);
  },
  "Form": function () {
    var x;
    return function () {
      x = this._apply("transFn");
      return [
        "this._form(",
        x,
        ")"
      ].join("");
    }.call(this);
  },
  "ConsBy": function () {
    var x;
    return function () {
      x = this._apply("transFn");
      return [
        "this._consumedBy(",
        x,
        ")"
      ].join("");
    }.call(this);
  },
  "IdxConsBy": function () {
    var x;
    return function () {
      x = this._apply("transFn");
      return [
        "this._idxConsumedBy(",
        x,
        ")"
      ].join("");
    }.call(this);
  },
  "JumpTable": function () {
    var cases;
    return function () {
      cases = this._many(function () {
        return this._apply("jtCase");
      });
      return this.jumpTableCode(cases);
    }.call(this);
  },
  "Interleave": function () {
    var xs;
    return function () {
      xs = this._many(function () {
        return this._apply("intPart");
      });
      return [
        "this._interleave(",
        xs.join(),
        ")"
      ].join("");
    }.call(this);
  },
  "Rule": function () {
    var name, ls, body;
    return function () {
      name = this._apply("anything");
      this.rName = name;
      ls = this._apply("locals");
      body = this._apply("trans");
      return [
        "\n\"",
        name,
        "\":function(){",
        ls,
        "return ",
        body,
        "}"
      ].join("");
    }.call(this);
  },
  "Grammar": function () {
    var name, sName, rules;
    return function () {
      name = this._apply("anything");
      sName = this._apply("anything");
      this.name = name;
      this.sName = sName;
      rules = this._many(function () {
        return this._apply("trans");
      });
      return [
        name,
        "=subclass(",
        sName,
        ",{",
        rules.join(),
        "});"
      ].join("");
    }.call(this);
  },
  "intPart": function () {
    var mode, part;
    return function () {
      this._form(function () {
        return function () {
          mode = this._apply("anything");
          return part = this._apply("transFn");
        }.call(this);
      });
      return programString(mode) + "," + part;
    }.call(this);
  },
  "jtCase": function () {
    var x, e;
    return function () {
      this._form(function () {
        return function () {
          x = this._apply("anything");
          return e = this._apply("trans");
        }.call(this);
      });
      return [
        programString(x),
        e
      ];
    }.call(this);
  },
  "locals": function () {
    var vs;
    return this._or(function () {
      return function () {
        this._form(function () {
          return vs = this._many1(function () {
            return this._apply("string");
          });
        });
        return [
          "var ",
          vs.join(),
          ";"
        ].join("");
      }.call(this);
    }, function () {
      return function () {
        this._form(function () {
          return undefined;
        });
        return "";
      }.call(this);
    });
  },
  "trans": function () {
    var t, ans;
    return function () {
      this._form(function () {
        return function () {
          t = this._apply("anything");
          return ans = this._applyWithArgs("apply", t);
        }.call(this);
      });
      return ans;
    }.call(this);
  },
  "transFn": function () {
    var x;
    return function () {
      x = this._apply("trans");
      return [
        "(function(){return ",
        x,
        "})"
      ].join("");
    }.call(this);
  }
});
BSOMetaTranslator.prototype.jumpTableCode = function (cases) {
  var key, val;
  return "(function(){switch(this._apply('anything')){" + function () {
    var _i, _len, _ref1, _results;
    _results = [];
    for (_i = 0, _len = cases.length; _i < _len; _i++) {
      _ref1 = cases[_i], key = _ref1[0], val = _ref1[1];
      _results.push("case " + key + ":return " + val + ";");
    }
    return _results;
  }().join("") + "default: throw this.fail}}).call(this)";
};
module.exports = {
  BSOMetaParser: BSOMetaParser,
  BSOMetaTranslator: BSOMetaTranslator
};

return module.exports;

});
define('bs-metacoffee-compiler',['require', 'exports', 'module', './ometa-base', 'coffee-script', './bs-dentparser', './bs-ometa-compiler', './ometa-lib'], function (require, exports, module) {
  

var BSCoffeeScriptCompiler, BSDentParser, BSOMetaParser, BSOMetaTranslator, OMeta, compileCoffeeScript, subclass, _ref;
OMeta = require("./ometa-base");
subclass = require("./ometa-lib").subclass;
BSCoffeeScriptCompiler = require("coffee-script");
BSDentParser = require("./bs-dentparser");
_ref = require("./bs-ometa-compiler"), BSOMetaParser = _ref.BSOMetaParser, BSOMetaTranslator = _ref.BSOMetaTranslator;
BSMetaCoffeeParser = subclass(BSDentParser, {
  "ometa": function () {
    var first, ss, g;
    return function () {
      first = this._apply("anything");
      this._or(function () {
        return this._pred(first);
      }, function () {
        return function () {
          switch (this._apply("anything")) {
          case "\n":
            return "\n";
          default:
            throw this.fail;
          }
        }.call(this);
      });
      ss = this._many(function () {
        return this._apply("inspace");
      });
      this._applyWithArgs("prepend", ss);
      g = this._applyWithArgs("foreign", BSOMetaParser, "grammar");
      return [
        "OMeta",
        ss.join(""),
        g
      ];
    }.call(this);
  },
  "coffee": function () {
    var x, xs;
    return function () {
      x = this._apply("anything");
      xs = this._many(function () {
        return function () {
          this._not(function () {
            return this._applyWithArgs("ometa", false);
          });
          return this._apply("anything");
        }.call(this);
      });
      return [
        "CoffeeScript",
        x + xs.join("")
      ];
    }.call(this);
  },
  "topLevel": function () {
    var x, xs;
    return this._or(function () {
      return function () {
        x = this._or(function () {
          return function () {
            this._many(function () {
              return this._apply("blankLine");
            });
            return this._applyWithArgs("ometa", true);
          }.call(this);
        }, function () {
          return this._apply("coffee");
        });
        xs = this._many(function () {
          return this._or(function () {
            return this._applyWithArgs("ometa", false);
          }, function () {
            return this._apply("coffee");
          });
        });
        return [x].concat(xs);
      }.call(this);
    }, function () {
      return function () {
        this._apply("end");
        return [[
            "CoffeeScript",
            ""
          ]];
      }.call(this);
    });
  }
});
compileCoffeeScript = function (source, bare) {
  var result;
  try {
    result = BSCoffeeScriptCompiler.compile(source, { bare: bare });
  } catch (e) {
    console.log("CoffeeScript SyntaxError in\n\n" + source);
    throw e;
  }
  return result;
};
BSMetaCoffeeTranslator = subclass(OMeta, {
  "trans": function () {
    var bare, t, ans, xs;
    return function () {
      bare = this._apply("anything");
      xs = this._many(function () {
        return function () {
          this._form(function () {
            return function () {
              t = this._apply("anything");
              return ans = this._applyWithArgs("apply", t);
            }.call(this);
          });
          return ans;
        }.call(this);
      });
      return compileCoffeeScript(xs.join(""), bare);
    }.call(this);
  },
  "CoffeeScript": function () {
    return this._apply("anything");
  },
  "OMeta": function () {
    var ss, t, js;
    return function () {
      ss = this._apply("anything");
      t = this._apply("anything");
      js = this._applyWithArgs("foreign", BSOMetaTranslator, "trans", t);
      return "\n" + ss + "`" + js + "`\n";
    }.call(this);
  }
});
module.exports = {
  BSMetaCoffeeParser: BSMetaCoffeeParser,
  BSMetaCoffeeTranslator: BSMetaCoffeeTranslator
};

return module.exports;

});
define('index',['require', 'exports', 'module', './ometa-base', './ometa-lib', './bs-metacoffee-compiler'], function (require, exports, module) {
  

var BSMetaCoffeeParser, BSMetaCoffeeTranslator, OMLib, OMeta, runtime, _ref;
OMeta = require("./ometa-base");
OMLib = require("./ometa-lib");
_ref = require("./bs-metacoffee-compiler"), BSMetaCoffeeParser = _ref.BSMetaCoffeeParser, BSMetaCoffeeTranslator = _ref.BSMetaCoffeeTranslator;
runtime = OMLib.extend({ OMeta: OMeta }, OMLib);
module.exports = {
  runtime: runtime,
  installRuntime: function (to) {
    return OMLib.extend(to, runtime);
  },
  compile: function (code, options) {
    var result, tree;
    if (options == null) {
      options = {};
    }
    tree = BSMetaCoffeeParser.matchAll(code, "topLevel", void 0, function (m, i) {
      var error;
      error = new SyntaxError("Parse error");
      error.position = i;
      throw error;
    });
    return result = BSMetaCoffeeTranslator.matchAll(tree, "trans", [options.bare], function (m, i) {
      throw new SyntaxError("Translation error");
    });
  }
};

return module.exports;

});    return require('index');
  };
if (__isAMD) {
  return define(['coffee-script', 'js-beautify'], bundleFactory);
} else {
    if (__isNode) {
        return module.exports = bundleFactory(require('coffee-script'), require('js-beautify'));
    } else {
        return bundleFactory((typeof BSCoffeeScriptCompiler !== 'undefined') ? BSCoffeeScriptCompiler : void 0, (typeof js_beautify !== 'undefined') ? js_beautify : void 0);
    }
}
}).call(this, (typeof exports === 'object' ? global : window),
              (typeof exports === 'object' ? global : window))